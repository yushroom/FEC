/* auto generated by codegen tools, do NOT modified this file directly. see
 * engine/source/codegen*/
#include "jsbinding.hpp"
extern "C" {
extern World *defaultWorld;
}

extern "C" {
JSClassID js_fe_Transform_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Transform>() {
    return js_fe_Transform_class_id;
}

static JSClassDef js_fe_Transform_class = {
    "Transform",
    .finalizer = NULL,
};

// Transform * parent getter
static JSValue js_fe_Transform_parent_getter(JSContext *ctx,
                                             JSValueConst this_val) {
    JSValue ret;
    Transform *value;
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    uint32_t p = TransformGetParent(tm, index);
    if (p == 0) return JS_NULL;
    value = (Transform *)array_at(&a->m, p);

    ret = JSValueFrom<Transform *>(ctx, value);
    return ret;
}
// Transform * parent setter
static JSValue js_fe_Transform_parent_setter(JSContext *ctx,
                                             JSValueConst this_val,
                                             JSValue val) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    Transform *value;
    if (JSValueTo<Transform *>(ctx, &value, val)) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    uint32_t parent = array_get_index(&a->m, value);
    const uint32_t child = index;
    TransformSetParent(tm, child, parent);

    return JS_UNDEFINED;
}
// float3 localPosition getter
static JSValue js_fe_Transform_localPosition_getter(JSContext *ctx,
                                                    JSValueConst this_val) {
    JSValue ret;
    float3 value;
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->localPosition;
    ret = JSValueFrom<float3>(ctx, value);
    return ret;
}
// float3 localPosition setter
static JSValue js_fe_Transform_localPosition_setter(JSContext *ctx,
                                                    JSValueConst this_val,
                                                    JSValue val) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    float3 value;
    if (JSValueTo<float3>(ctx, &value, val)) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    self->localPosition = value;
    TransformSetDirty(tm, index);

    return JS_UNDEFINED;
}
// quat localRotation getter
static JSValue js_fe_Transform_localRotation_getter(JSContext *ctx,
                                                    JSValueConst this_val) {
    JSValue ret;
    quat value;
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->localRotation;
    ret = JSValueFrom<quat>(ctx, value);
    return ret;
}
// quat localRotation setter
static JSValue js_fe_Transform_localRotation_setter(JSContext *ctx,
                                                    JSValueConst this_val,
                                                    JSValue val) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    quat value;
    if (JSValueTo<quat>(ctx, &value, val)) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    self->localRotation = value;
    TransformSetDirty(tm, index);

    return JS_UNDEFINED;
}
// float3 localEulerAngles getter
static JSValue js_fe_Transform_localEulerAngles_getter(JSContext *ctx,
                                                       JSValueConst this_val) {
    JSValue ret;
    float3 value;
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;

    value = quat_to_euler(self->localRotation);

    ret = JSValueFrom<float3>(ctx, value);
    return ret;
}
// float3 localEulerAngles setter
static JSValue js_fe_Transform_localEulerAngles_setter(JSContext *ctx,
                                                       JSValueConst this_val,
                                                       JSValue val) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    float3 value;
    if (JSValueTo<float3>(ctx, &value, val)) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    self->localRotation = euler_to_quat(value);
    TransformSetDirty(tm, index);

    return JS_UNDEFINED;
}
// float3 localScale getter
static JSValue js_fe_Transform_localScale_getter(JSContext *ctx,
                                                 JSValueConst this_val) {
    JSValue ret;
    float3 value;
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->localScale;
    ret = JSValueFrom<float3>(ctx, value);
    return ret;
}
// float3 localScale setter
static JSValue js_fe_Transform_localScale_setter(JSContext *ctx,
                                                 JSValueConst this_val,
                                                 JSValue val) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    float3 value;
    if (JSValueTo<float3>(ctx, &value, val)) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    self->localScale = value;
    TransformSetDirty(tm, index);

    return JS_UNDEFINED;
}
// float3 position getter
static JSValue js_fe_Transform_position_getter(JSContext *ctx,
                                               JSValueConst this_val) {
    JSValue ret;
    float3 value;
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    value = TransformGetPosition(tm, defaultWorld, index);

    ret = JSValueFrom<float3>(ctx, value);
    return ret;
}
// float4x4 localMatrix setter
static JSValue js_fe_Transform_localMatrix_setter(JSContext *ctx,
                                                  JSValueConst this_val,
                                                  JSValue val) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_val, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;
    float4x4 value;
    if (JSValueTo<float4x4>(ctx, &value, val)) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    float4x4_decompose(&value, &self->localPosition, &self->localRotation,
                       &self->localScale);
    TransformSetDirty(tm, index);

    return JS_UNDEFINED;
}

static JSValue js_fe_Transform_LookAt(JSContext *ctx, JSValueConst this_value,
                                      int argc, JSValueConst *argv) {
    Transform *self =
        (Transform *)JS_GetOpaque2(ctx, this_value, js_fe_Transform_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    float3 target;
    if (JSValueTo<float3>(ctx, &target, argv[0])) return JS_EXCEPTION;

    SingletonTransformManager *tm =
        (SingletonTransformManager *)WorldGetSingletonComponent(
            defaultWorld, SingletonTransformManagerID);
    ComponentArray *a = &defaultWorld->componentArrays[TransformID];
    uint32_t index = array_get_index(&a->m, self);
    TransformLookAt(tm, defaultWorld, index, target);

    JSValueFree<float3>(ctx, target);

    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Transform_proto_funcs[] = {
    JS_CGETSET_DEF("parent", js_fe_Transform_parent_getter,
                   js_fe_Transform_parent_setter),
    JS_CGETSET_DEF("localPosition", js_fe_Transform_localPosition_getter,
                   js_fe_Transform_localPosition_setter),
    JS_CGETSET_DEF("localRotation", js_fe_Transform_localRotation_getter,
                   js_fe_Transform_localRotation_setter),
    JS_CGETSET_DEF("localEulerAngles", js_fe_Transform_localEulerAngles_getter,
                   js_fe_Transform_localEulerAngles_setter),
    JS_CGETSET_DEF("localScale", js_fe_Transform_localScale_getter,
                   js_fe_Transform_localScale_setter),
    JS_CGETSET_DEF("position", js_fe_Transform_position_getter, NULL),
    JS_CGETSET_DEF("localMatrix", NULL, js_fe_Transform_localMatrix_setter),
    JS_CFUNC_DEF("LookAt", 1, js_fe_Transform_LookAt),
};

extern "C" {
JSClassID js_fe_Camera_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Camera>() {
    return js_fe_Camera_class_id;
}

static JSClassDef js_fe_Camera_class = {
    "Camera",
    .finalizer = NULL,
};

// float fieldOfView getter
static JSValue js_fe_Camera_fieldOfView_getter(JSContext *ctx,
                                               JSValueConst this_val) {
    JSValue ret;
    float value;
    Camera *self =
        (Camera *)JS_GetOpaque2(ctx, this_val, js_fe_Camera_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->fieldOfView;
    ret = JSValueFrom<float>(ctx, value);
    return ret;
}
// float fieldOfView setter
static JSValue js_fe_Camera_fieldOfView_setter(JSContext *ctx,
                                               JSValueConst this_val,
                                               JSValue val) {
    Camera *self =
        (Camera *)JS_GetOpaque2(ctx, this_val, js_fe_Camera_class_id);
    if (!self) return JS_EXCEPTION;
    float value;
    if (JSValueTo<float>(ctx, &value, val)) return JS_EXCEPTION;
    self->fieldOfView = value;
    return JS_UNDEFINED;
}
// float nearClipPlane getter
static JSValue js_fe_Camera_nearClipPlane_getter(JSContext *ctx,
                                                 JSValueConst this_val) {
    JSValue ret;
    float value;
    Camera *self =
        (Camera *)JS_GetOpaque2(ctx, this_val, js_fe_Camera_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->nearClipPlane;
    ret = JSValueFrom<float>(ctx, value);
    return ret;
}
// float nearClipPlane setter
static JSValue js_fe_Camera_nearClipPlane_setter(JSContext *ctx,
                                                 JSValueConst this_val,
                                                 JSValue val) {
    Camera *self =
        (Camera *)JS_GetOpaque2(ctx, this_val, js_fe_Camera_class_id);
    if (!self) return JS_EXCEPTION;
    float value;
    if (JSValueTo<float>(ctx, &value, val)) return JS_EXCEPTION;
    self->nearClipPlane = value;
    return JS_UNDEFINED;
}
// float farClipPlane getter
static JSValue js_fe_Camera_farClipPlane_getter(JSContext *ctx,
                                                JSValueConst this_val) {
    JSValue ret;
    float value;
    Camera *self =
        (Camera *)JS_GetOpaque2(ctx, this_val, js_fe_Camera_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->farClipPlane;
    ret = JSValueFrom<float>(ctx, value);
    return ret;
}
// float farClipPlane setter
static JSValue js_fe_Camera_farClipPlane_setter(JSContext *ctx,
                                                JSValueConst this_val,
                                                JSValue val) {
    Camera *self =
        (Camera *)JS_GetOpaque2(ctx, this_val, js_fe_Camera_class_id);
    if (!self) return JS_EXCEPTION;
    float value;
    if (JSValueTo<float>(ctx, &value, val)) return JS_EXCEPTION;
    self->farClipPlane = value;
    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Camera_proto_funcs[] = {
    JS_CGETSET_DEF("fieldOfView", js_fe_Camera_fieldOfView_getter,
                   js_fe_Camera_fieldOfView_setter),
    JS_CGETSET_DEF("nearClipPlane", js_fe_Camera_nearClipPlane_getter,
                   js_fe_Camera_nearClipPlane_setter),
    JS_CGETSET_DEF("farClipPlane", js_fe_Camera_farClipPlane_getter,
                   js_fe_Camera_farClipPlane_setter),
};

extern "C" {
JSClassID js_fe_Texture_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Texture>() {
    return js_fe_Texture_class_id;
}

static JSClassDef js_fe_Texture_class = {
    "Texture",
    .finalizer = NULL,
};

static JSValue js_fe_Texture_ctor(JSContext *ctx, JSValueConst new_target,
                                  int argc, JSValueConst *argv) {
    Texture *self = NULL;
    JSValue proto;
    JSValue obj = JS_UNDEFINED;

    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto)) return proto;
    obj = JS_NewObjectProtoClass(ctx, proto, js_fe_Texture_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj)) {
        return obj;
    }

    // AssetID aid;
    // self = (Texture *)AssetNew(AssetTypeTexture, &aid);
    self = (Texture *)TextureNew();

    JS_SetOpaque(obj, self);
    return obj;
}

// uint32_t width getter
static JSValue js_fe_Texture_width_getter(JSContext *ctx,
                                          JSValueConst this_val) {
    JSValue ret;
    uint32_t value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->width;
    ret = JSValueFrom<uint32_t>(ctx, value);
    return ret;
}
// uint32_t height getter
static JSValue js_fe_Texture_height_getter(JSContext *ctx,
                                           JSValueConst this_val) {
    JSValue ret;
    uint32_t value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->height;
    ret = JSValueFrom<uint32_t>(ctx, value);
    return ret;
}
// uint32_t mipmaps getter
static JSValue js_fe_Texture_mipmaps_getter(JSContext *ctx,
                                            JSValueConst this_val) {
    JSValue ret;
    uint32_t value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->mipmaps;
    ret = JSValueFrom<uint32_t>(ctx, value);
    return ret;
}
// TextureDimension dimension getter
static JSValue js_fe_Texture_dimension_getter(JSContext *ctx,
                                              JSValueConst this_val) {
    JSValue ret;
    TextureDimension value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->dimension;
    ret = JSValueFrom<TextureDimension>(ctx, value);
    return ret;
}
// FilterMode filterMode getter
static JSValue js_fe_Texture_filterMode_getter(JSContext *ctx,
                                               JSValueConst this_val) {
    JSValue ret;
    FilterMode value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->filterMode;
    ret = JSValueFrom<FilterMode>(ctx, value);
    return ret;
}
// FilterMode filterMode setter
static JSValue js_fe_Texture_filterMode_setter(JSContext *ctx,
                                               JSValueConst this_val,
                                               JSValue val) {
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    FilterMode value;
    if (JSValueTo<FilterMode>(ctx, &value, val)) return JS_EXCEPTION;
    self->filterMode = value;
    return JS_UNDEFINED;
}
// TextureWrapMode wrapModeU getter
static JSValue js_fe_Texture_wrapModeU_getter(JSContext *ctx,
                                              JSValueConst this_val) {
    JSValue ret;
    TextureWrapMode value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->wrapModeU;
    ret = JSValueFrom<TextureWrapMode>(ctx, value);
    return ret;
}
// TextureWrapMode wrapModeU setter
static JSValue js_fe_Texture_wrapModeU_setter(JSContext *ctx,
                                              JSValueConst this_val,
                                              JSValue val) {
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    TextureWrapMode value;
    if (JSValueTo<TextureWrapMode>(ctx, &value, val)) return JS_EXCEPTION;
    self->wrapModeU = value;
    return JS_UNDEFINED;
}
// TextureWrapMode wrapModeV getter
static JSValue js_fe_Texture_wrapModeV_getter(JSContext *ctx,
                                              JSValueConst this_val) {
    JSValue ret;
    TextureWrapMode value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->wrapModeV;
    ret = JSValueFrom<TextureWrapMode>(ctx, value);
    return ret;
}
// TextureWrapMode wrapModeV setter
static JSValue js_fe_Texture_wrapModeV_setter(JSContext *ctx,
                                              JSValueConst this_val,
                                              JSValue val) {
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    TextureWrapMode value;
    if (JSValueTo<TextureWrapMode>(ctx, &value, val)) return JS_EXCEPTION;
    self->wrapModeV = value;
    return JS_UNDEFINED;
}
// TextureWrapMode wrapModeW getter
static JSValue js_fe_Texture_wrapModeW_getter(JSContext *ctx,
                                              JSValueConst this_val) {
    JSValue ret;
    TextureWrapMode value;
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->wrapModeW;
    ret = JSValueFrom<TextureWrapMode>(ctx, value);
    return ret;
}
// TextureWrapMode wrapModeW setter
static JSValue js_fe_Texture_wrapModeW_setter(JSContext *ctx,
                                              JSValueConst this_val,
                                              JSValue val) {
    Texture *self =
        (Texture *)JS_GetOpaque2(ctx, this_val, js_fe_Texture_class_id);
    if (!self) return JS_EXCEPTION;
    TextureWrapMode value;
    if (JSValueTo<TextureWrapMode>(ctx, &value, val)) return JS_EXCEPTION;
    self->wrapModeW = value;
    return JS_UNDEFINED;
}

static JSValue js_fe_Texture_FromDDSFile(JSContext *ctx,
                                         JSValueConst this_value, int argc,
                                         JSValueConst *argv) {
    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    string path;
    if (JSValueTo<string>(ctx, &path, argv[0])) return JS_EXCEPTION;
    Texture *ret;

    ret = TextureFromDDSFile(path);

    JSValueFree<string>(ctx, path);

    return JSValueFrom<Texture *>(ctx, ret);
}

static const JSCFunctionListEntry js_fe_Texture_proto_funcs[] = {
    JS_CGETSET_DEF("width", js_fe_Texture_width_getter, NULL),
    JS_CGETSET_DEF("height", js_fe_Texture_height_getter, NULL),
    JS_CGETSET_DEF("mipmaps", js_fe_Texture_mipmaps_getter, NULL),
    JS_CGETSET_DEF("dimension", js_fe_Texture_dimension_getter, NULL),
    JS_CGETSET_DEF("filterMode", js_fe_Texture_filterMode_getter,
                   js_fe_Texture_filterMode_setter),
    JS_CGETSET_DEF("wrapModeU", js_fe_Texture_wrapModeU_getter,
                   js_fe_Texture_wrapModeU_setter),
    JS_CGETSET_DEF("wrapModeV", js_fe_Texture_wrapModeV_getter,
                   js_fe_Texture_wrapModeV_setter),
    JS_CGETSET_DEF("wrapModeW", js_fe_Texture_wrapModeW_getter,
                   js_fe_Texture_wrapModeW_setter),
};

extern "C" {
JSClassID js_fe_Shader_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Shader>() {
    return js_fe_Shader_class_id;
}

static JSClassDef js_fe_Shader_class = {
    "Shader",
    .finalizer = NULL,
};

static JSValue js_fe_Shader_ctor(JSContext *ctx, JSValueConst new_target,
                                 int argc, JSValueConst *argv) {
    Shader *self = NULL;
    JSValue proto;
    JSValue obj = JS_UNDEFINED;

    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto)) return proto;
    obj = JS_NewObjectProtoClass(ctx, proto, js_fe_Shader_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj)) {
        return obj;
    }

    JS_SetOpaque(obj, self);
    return obj;
}

static JSValue js_fe_Shader_FromFile(JSContext *ctx, JSValueConst this_value,
                                     int argc, JSValueConst *argv) {
    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    string path;
    if (JSValueTo<string>(ctx, &path, argv[0])) return JS_EXCEPTION;
    Shader *ret;

    ret = ShaderFromFile(path);

    JSValueFree<string>(ctx, path);

    return JSValueFrom<Shader *>(ctx, ret);
}
static JSValue js_fe_Shader_PropertyToID(JSContext *ctx,
                                         JSValueConst this_value, int argc,
                                         JSValueConst *argv) {
    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    string name;
    if (JSValueTo<string>(ctx, &name, argv[0])) return JS_EXCEPTION;
    int ret;

    ret = ShaderPropertyToID(name);

    JSValueFree<string>(ctx, name);

    return JSValueFrom<int>(ctx, ret);
}

static const JSCFunctionListEntry js_fe_Shader_proto_funcs[] = {};

extern "C" {
JSClassID js_fe_Skin_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Skin>() {
    return js_fe_Skin_class_id;
}

static JSClassDef js_fe_Skin_class = {
    "Skin",
    .finalizer = NULL,
};

static JSValue js_fe_Skin_ctor(JSContext *ctx, JSValueConst new_target,
                               int argc, JSValueConst *argv) {
    Skin *self = NULL;
    JSValue proto;
    JSValue obj = JS_UNDEFINED;

    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto)) return proto;
    obj = JS_NewObjectProtoClass(ctx, proto, js_fe_Skin_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj)) {
        return obj;
    }

    self = SkinNew();

    JS_SetOpaque(obj, self);
    return obj;
}

// Entity root getter
static JSValue js_fe_Skin_root_getter(JSContext *ctx, JSValueConst this_val) {
    JSValue ret;
    Entity value;
    Skin *self = (Skin *)JS_GetOpaque2(ctx, this_val, js_fe_Skin_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->root;
    ret = JSValueFrom<Entity>(ctx, value);
    return ret;
}
// Entity root setter
static JSValue js_fe_Skin_root_setter(JSContext *ctx, JSValueConst this_val,
                                      JSValue val) {
    Skin *self = (Skin *)JS_GetOpaque2(ctx, this_val, js_fe_Skin_class_id);
    if (!self) return JS_EXCEPTION;
    Entity value;
    if (JSValueTo<Entity>(ctx, &value, val)) return JS_EXCEPTION;
    self->root = value;
    return JS_UNDEFINED;
}
// TypedArray inverseBindMatrices setter
static JSValue js_fe_Skin_inverseBindMatrices_setter(JSContext *ctx,
                                                     JSValueConst this_val,
                                                     JSValue val) {
    Skin *self = (Skin *)JS_GetOpaque2(ctx, this_val, js_fe_Skin_class_id);
    if (!self) return JS_EXCEPTION;
    TypedArray value;
    if (JSValueTo<TypedArray>(ctx, &value, val)) return JS_EXCEPTION;

    assert(self->inverseBindMatrices.stride == sizeof(float4x4));
    array_resize(&self->inverseBindMatrices,
                 value.byteLength / sizeof(float4x4));
    memcpy(self->inverseBindMatrices.ptr, value.buffer, value.byteLength);
    // float4x4 *p = (float4x4 *)self->inverseBindMatrices.ptr;
    // for (int i = 0; i < self->inverseBindMatrices.size; ++i, ++p) {
    //     // *p = float4x4_transpose(*p);
    //     p->m10 = -p->m10;
    //     p->m20 = -p->m20;
    //     p->m01 = -p->m01;
    //     p->m02 = -p->m02;
    //     p->m03 = -p->m03;
    // }

    return JS_UNDEFINED;
}
// TypedArray joints setter
static JSValue js_fe_Skin_joints_setter(JSContext *ctx, JSValueConst this_val,
                                        JSValue val) {
    Skin *self = (Skin *)JS_GetOpaque2(ctx, this_val, js_fe_Skin_class_id);
    if (!self) return JS_EXCEPTION;
    TypedArray value;
    if (JSValueTo<TypedArray>(ctx, &value, val)) return JS_EXCEPTION;

    assert(self->joints.stride == sizeof(Entity));
    assert(value.bytesPerElement == sizeof(Entity));
    array_resize(&self->joints, value.byteLength / sizeof(Entity));
    memcpy(self->joints.ptr, value.buffer, value.byteLength);

    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Skin_proto_funcs[] = {
    JS_CGETSET_DEF("root", js_fe_Skin_root_getter, js_fe_Skin_root_setter),
    JS_CGETSET_DEF("inverseBindMatrices", NULL,
                   js_fe_Skin_inverseBindMatrices_setter),
    JS_CGETSET_DEF("joints", NULL, js_fe_Skin_joints_setter),
};

extern "C" {
JSClassID js_fe_Mesh_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Mesh>() {
    return js_fe_Mesh_class_id;
}

static JSClassDef js_fe_Mesh_class = {
    "Mesh",
    .finalizer = NULL,
};

static JSValue js_fe_Mesh_ctor(JSContext *ctx, JSValueConst new_target,
                               int argc, JSValueConst *argv) {
    Mesh *self = NULL;
    JSValue proto;
    JSValue obj = JS_UNDEFINED;

    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto)) return proto;
    obj = JS_NewObjectProtoClass(ctx, proto, js_fe_Mesh_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj)) {
        return obj;
    }

    // AssetID aid;
    // self = (Mesh *)AssetNew(AssetTypeMesh, &aid);
    self = (Mesh *)MeshNew();
    self->refcount = 1;

    JS_SetOpaque(obj, self);
    return obj;
}

// TypedArray triangles setter
static JSValue js_fe_Mesh_triangles_setter(JSContext *ctx,
                                           JSValueConst this_val, JSValue val) {
    Mesh *self = (Mesh *)JS_GetOpaque2(ctx, this_val, js_fe_Mesh_class_id);
    if (!self) return JS_EXCEPTION;
    TypedArray value;
    if (JSValueTo<TypedArray>(ctx, &value, val)) return JS_EXCEPTION;

    // TypedArray value;
    MeshSetTriangles(self, value.buffer, value.byteLength,
                     value.bytesPerElement);

    return JS_UNDEFINED;
}

static JSValue js_fe_Mesh_Clear(JSContext *ctx, JSValueConst this_value,
                                int argc, JSValueConst *argv) {
    Mesh *self = (Mesh *)JS_GetOpaque2(ctx, this_value, js_fe_Mesh_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 0) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception

    MeshClear(self);

    return JS_UNDEFINED;
}
static JSValue js_fe_Mesh_SetVertices(JSContext *ctx, JSValueConst this_value,
                                      int argc, JSValueConst *argv) {
    Mesh *self = (Mesh *)JS_GetOpaque2(ctx, this_value, js_fe_Mesh_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 5) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    enum VertexAttr attr;
    if (JSValueTo<enum VertexAttr>(ctx, &attr, argv[0])) return JS_EXCEPTION;
    ArrayBuffer buf;
    if (JSValueTo<ArrayBuffer>(ctx, &buf, argv[1])) return JS_EXCEPTION;
    uint32_t count;
    if (JSValueTo<uint32_t>(ctx, &count, argv[2])) return JS_EXCEPTION;
    uint32_t byteOffset;
    if (JSValueTo<uint32_t>(ctx, &byteOffset, argv[3])) return JS_EXCEPTION;
    uint32_t stride;
    if (JSValueTo<uint32_t>(ctx, &stride, argv[4])) return JS_EXCEPTION;

    // TODO: use TypedArray instead of ArrayBuffer
    assert(byteOffset + count * stride <= buf.byteLength);
    MeshSetVertices(self, attr, buf.buffer + byteOffset, count, stride);

    JSValueFree<enum VertexAttr>(ctx, attr);
    JSValueFree<ArrayBuffer>(ctx, buf);
    JSValueFree<uint32_t>(ctx, count);
    JSValueFree<uint32_t>(ctx, byteOffset);
    JSValueFree<uint32_t>(ctx, stride);

    return JS_UNDEFINED;
}
static JSValue js_fe_Mesh_UploadMeshData(JSContext *ctx,
                                         JSValueConst this_value, int argc,
                                         JSValueConst *argv) {
    Mesh *self = (Mesh *)JS_GetOpaque2(ctx, this_value, js_fe_Mesh_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 0) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception

    MeshUploadMeshData(self);

    return JS_UNDEFINED;
}
static JSValue js_fe_Mesh_CombineMeshes(JSContext *ctx, JSValueConst this_value,
                                        int argc, JSValueConst *argv) {
    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    Array array;
    if (JSValueTo<Array>(ctx, &array, argv[0])) return JS_EXCEPTION;
    Mesh *ret;

    assert(array.size < 32);
    Mesh *meshes[array.size];
    for (int i = 0; i < array.size; ++i) {
        JSValue x = array[i];
        Mesh *mesh = (Mesh *)JS_GetOpaque2(ctx, array[i], js_fe_Mesh_class_id);
        JS_FreeValue(ctx, x);
        if (!mesh) return JS_EXCEPTION;
        meshes[i] = mesh;
    }

    ret = MeshCombine(meshes, array.size);

    JSValueFree<Array>(ctx, array);

    return JSValueFrom<Mesh *>(ctx, ret);
}

static const JSCFunctionListEntry js_fe_Mesh_proto_funcs[] = {
    JS_CGETSET_DEF("triangles", NULL, js_fe_Mesh_triangles_setter),
    JS_CFUNC_DEF("Clear", 0, js_fe_Mesh_Clear),
    JS_CFUNC_DEF("SetVertices", 5, js_fe_Mesh_SetVertices),
    JS_CFUNC_DEF("UploadMeshData", 0, js_fe_Mesh_UploadMeshData),
};

extern "C" {
JSClassID js_fe_Material_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Material>() {
    return js_fe_Material_class_id;
}

static JSClassDef js_fe_Material_class = {
    "Material",
    .finalizer = NULL,
};

static JSValue js_fe_Material_ctor(JSContext *ctx, JSValueConst new_target,
                                   int argc, JSValueConst *argv) {
    Material *self = NULL;
    JSValue proto;
    JSValue obj = JS_UNDEFINED;

    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto)) return proto;
    obj = JS_NewObjectProtoClass(ctx, proto, js_fe_Material_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj)) {
        return obj;
    }

    self = (Material *)MaterialNew();

    JS_SetOpaque(obj, self);
    return obj;
}

// Texture * mainTexture getter
static JSValue js_fe_Material_mainTexture_getter(JSContext *ctx,
                                                 JSValueConst this_val) {
    JSValue ret;
    Texture *value;
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_val, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->mainTexture;
    ret = JSValueFrom<Texture *>(ctx, value);
    return ret;
}
// Texture * mainTexture setter
static JSValue js_fe_Material_mainTexture_setter(JSContext *ctx,
                                                 JSValueConst this_val,
                                                 JSValue val) {
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_val, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;
    Texture *value;
    if (JSValueTo<Texture *>(ctx, &value, val)) return JS_EXCEPTION;
    self->mainTexture = value;
    return JS_UNDEFINED;
}
// float4 color getter
static JSValue js_fe_Material_color_getter(JSContext *ctx,
                                           JSValueConst this_val) {
    JSValue ret;
    float4 value;
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_val, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->color;
    ret = JSValueFrom<float4>(ctx, value);
    return ret;
}
// float4 color setter
static JSValue js_fe_Material_color_setter(JSContext *ctx,
                                           JSValueConst this_val, JSValue val) {
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_val, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;
    float4 value;
    if (JSValueTo<float4>(ctx, &value, val)) return JS_EXCEPTION;
    self->color = value;
    return JS_UNDEFINED;
}

static JSValue js_fe_Material_SetFloat(JSContext *ctx, JSValueConst this_value,
                                       int argc, JSValueConst *argv) {
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_value, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 2) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    string name;
    if (JSValueTo<string>(ctx, &name, argv[0])) return JS_EXCEPTION;
    float value;
    if (JSValueTo<float>(ctx, &value, argv[1])) return JS_EXCEPTION;

    int nameID = ShaderPropertyToID(name);
    MaterialSetFloat(self, nameID, value);

    JSValueFree<string>(ctx, name);
    JSValueFree<float>(ctx, value);

    return JS_UNDEFINED;
}
static JSValue js_fe_Material_SetVector(JSContext *ctx, JSValueConst this_value,
                                        int argc, JSValueConst *argv) {
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_value, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 2) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    string name;
    if (JSValueTo<string>(ctx, &name, argv[0])) return JS_EXCEPTION;
    float4 value;
    if (JSValueTo<float4>(ctx, &value, argv[1])) return JS_EXCEPTION;

    int nameID = ShaderPropertyToID(name);
    MaterialSetVector(self, nameID, value);

    JSValueFree<string>(ctx, name);
    JSValueFree<float4>(ctx, value);

    return JS_UNDEFINED;
}
static JSValue js_fe_Material_SetTexture(JSContext *ctx,
                                         JSValueConst this_value, int argc,
                                         JSValueConst *argv) {
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_value, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 2) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    string name;
    if (JSValueTo<string>(ctx, &name, argv[0])) return JS_EXCEPTION;
    Texture *value;
    if (JSValueTo<Texture *>(ctx, &value, argv[1])) return JS_EXCEPTION;

    int nameID = ShaderPropertyToID(name);
    MaterialSetTexture(self, nameID, value);

    JSValueFree<string>(ctx, name);
    JSValueFree<Texture *>(ctx, value);

    return JS_UNDEFINED;
}
static JSValue js_fe_Material_SetShader(JSContext *ctx, JSValueConst this_value,
                                        int argc, JSValueConst *argv) {
    Material *self =
        (Material *)JS_GetOpaque2(ctx, this_value, js_fe_Material_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    Shader *shader;
    if (JSValueTo<Shader *>(ctx, &shader, argv[0])) return JS_EXCEPTION;

    MaterialSetShader(self, shader);

    JSValueFree<Shader *>(ctx, shader);

    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Material_proto_funcs[] = {
    JS_CGETSET_DEF("mainTexture", js_fe_Material_mainTexture_getter,
                   js_fe_Material_mainTexture_setter),
    JS_CGETSET_DEF("color", js_fe_Material_color_getter,
                   js_fe_Material_color_setter),
    JS_CFUNC_DEF("SetFloat", 2, js_fe_Material_SetFloat),
    JS_CFUNC_DEF("SetVector", 2, js_fe_Material_SetVector),
    JS_CFUNC_DEF("SetTexture", 2, js_fe_Material_SetTexture),
    JS_CFUNC_DEF("SetShader", 1, js_fe_Material_SetShader),
};

extern "C" {
JSClassID js_fe_Renderable_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Renderable>() {
    return js_fe_Renderable_class_id;
}

static JSClassDef js_fe_Renderable_class = {
    "Renderable",
    .finalizer = NULL,
};

// Mesh * mesh getter
static JSValue js_fe_Renderable_mesh_getter(JSContext *ctx,
                                            JSValueConst this_val) {
    JSValue ret;
    Mesh *value;
    Renderable *self =
        (Renderable *)JS_GetOpaque2(ctx, this_val, js_fe_Renderable_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->mesh;
    ret = JSValueFrom<Mesh *>(ctx, value);
    return ret;
}
// Mesh * mesh setter
static JSValue js_fe_Renderable_mesh_setter(JSContext *ctx,
                                            JSValueConst this_val,
                                            JSValue val) {
    Renderable *self =
        (Renderable *)JS_GetOpaque2(ctx, this_val, js_fe_Renderable_class_id);
    if (!self) return JS_EXCEPTION;
    Mesh *value;
    if (JSValueTo<Mesh *>(ctx, &value, val)) return JS_EXCEPTION;

    RenderableSetMesh(self, value);

    return JS_UNDEFINED;
}
// Material * material getter
static JSValue js_fe_Renderable_material_getter(JSContext *ctx,
                                                JSValueConst this_val) {
    JSValue ret;
    Material *value;
    Renderable *self =
        (Renderable *)JS_GetOpaque2(ctx, this_val, js_fe_Renderable_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->material;
    ret = JSValueFrom<Material *>(ctx, value);
    return ret;
}
// Material * material setter
static JSValue js_fe_Renderable_material_setter(JSContext *ctx,
                                                JSValueConst this_val,
                                                JSValue val) {
    Renderable *self =
        (Renderable *)JS_GetOpaque2(ctx, this_val, js_fe_Renderable_class_id);
    if (!self) return JS_EXCEPTION;
    Material *value;
    if (JSValueTo<Material *>(ctx, &value, val)) return JS_EXCEPTION;
    self->material = value;
    return JS_UNDEFINED;
}
// Skin * skin getter
static JSValue js_fe_Renderable_skin_getter(JSContext *ctx,
                                            JSValueConst this_val) {
    JSValue ret;
    Skin *value;
    Renderable *self =
        (Renderable *)JS_GetOpaque2(ctx, this_val, js_fe_Renderable_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->skin;
    ret = JSValueFrom<Skin *>(ctx, value);
    return ret;
}
// Skin * skin setter
static JSValue js_fe_Renderable_skin_setter(JSContext *ctx,
                                            JSValueConst this_val,
                                            JSValue val) {
    Renderable *self =
        (Renderable *)JS_GetOpaque2(ctx, this_val, js_fe_Renderable_class_id);
    if (!self) return JS_EXCEPTION;
    Skin *value;
    if (JSValueTo<Skin *>(ctx, &value, val)) return JS_EXCEPTION;
    self->skin = value;
    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Renderable_proto_funcs[] = {
    JS_CGETSET_DEF("mesh", js_fe_Renderable_mesh_getter,
                   js_fe_Renderable_mesh_setter),
    JS_CGETSET_DEF("material", js_fe_Renderable_material_getter,
                   js_fe_Renderable_material_setter),
    JS_CGETSET_DEF("skin", js_fe_Renderable_skin_getter,
                   js_fe_Renderable_skin_setter),
};

extern "C" {
JSClassID js_fe_AnimationClip_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<AnimationClip>() {
    return js_fe_AnimationClip_class_id;
}

static JSClassDef js_fe_AnimationClip_class = {
    "AnimationClip",
    .finalizer = NULL,
};

static JSValue js_fe_AnimationClip_ctor(JSContext *ctx, JSValueConst new_target,
                                        int argc, JSValueConst *argv) {
    AnimationClip *self = NULL;
    JSValue proto;
    JSValue obj = JS_UNDEFINED;

    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto)) return proto;
    obj = JS_NewObjectProtoClass(ctx, proto, js_fe_AnimationClip_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj)) {
        return obj;
    }

    self = (AnimationClip *)AnimationClipNew();

    JS_SetOpaque(obj, self);
    return obj;
}

// float frameRate getter
static JSValue js_fe_AnimationClip_frameRate_getter(JSContext *ctx,
                                                    JSValueConst this_val) {
    JSValue ret;
    float value;
    AnimationClip *self = (AnimationClip *)JS_GetOpaque2(
        ctx, this_val, js_fe_AnimationClip_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->frameRate;
    ret = JSValueFrom<float>(ctx, value);
    return ret;
}
// float frameRate setter
static JSValue js_fe_AnimationClip_frameRate_setter(JSContext *ctx,
                                                    JSValueConst this_val,
                                                    JSValue val) {
    AnimationClip *self = (AnimationClip *)JS_GetOpaque2(
        ctx, this_val, js_fe_AnimationClip_class_id);
    if (!self) return JS_EXCEPTION;
    float value;
    if (JSValueTo<float>(ctx, &value, val)) return JS_EXCEPTION;
    self->frameRate = value;
    return JS_UNDEFINED;
}
// float length getter
static JSValue js_fe_AnimationClip_length_getter(JSContext *ctx,
                                                 JSValueConst this_val) {
    JSValue ret;
    float value;
    AnimationClip *self = (AnimationClip *)JS_GetOpaque2(
        ctx, this_val, js_fe_AnimationClip_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->length;
    ret = JSValueFrom<float>(ctx, value);
    return ret;
}

static JSValue js_fe_AnimationClip_SetCurve(JSContext *ctx,
                                            JSValueConst this_value, int argc,
                                            JSValueConst *argv) {
    AnimationClip *self = (AnimationClip *)JS_GetOpaque2(
        ctx, this_value, js_fe_AnimationClip_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 4) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    Entity target;
    if (JSValueTo<Entity>(ctx, &target, argv[0])) return JS_EXCEPTION;
    TypedArray input;
    if (JSValueTo<TypedArray>(ctx, &input, argv[1])) return JS_EXCEPTION;
    TypedArray output;
    if (JSValueTo<TypedArray>(ctx, &output, argv[2])) return JS_EXCEPTION;
    string propertyName;
    if (JSValueTo<string>(ctx, &propertyName, argv[3])) return JS_EXCEPTION;

    AnimationCurve *curve = (AnimationCurve *)array_push(&self->curves);
    AnimationCurveInit(curve);
    curve->target = target;
    array_from_TypedArray(&curve->input, &input);
    curve->input.stride = sizeof(float);
    uint32_t count = input.byteLength / input.bytesPerElement;
    array_from_TypedArray(&curve->output, &output);
    if (strcmp(propertyName, "translation") == 0) {
        curve->type = AnimationCurveTypeTranslation;
        curve->output.stride = 3 * 4;
        // float3 *p = (float3 *)curve->output.ptr;
        // for (int i = 0; i < count; ++i, ++p) {
        //     p->x = -p->x;
        // }
    } else if (strcmp(propertyName, "rotation") == 0) {
        curve->type = AnimationCurveTypeRotation;
        curve->output.stride = 4 * 4;
        quat *p = (quat *)curve->output.ptr;
        for (int i = 0; i < count; ++i, ++p) {
            // p->y = -p->y;
            // p->z = -p->z;
            *p = quat_normalize(*p);
        }
    } else if (strcmp(propertyName, "scale") == 0) {
        curve->type = AnimationCurveTypeScale;
        curve->output.stride = 3 * 4;
    } else {
        curve->type = AnimationCurveTypeWeights;
    }
    float length = *((float *)array_reverse_at(&curve->input, 0));  // last time
    self->length = self->length >= length ? self->length : length;

    JSValueFree<Entity>(ctx, target);
    JSValueFree<TypedArray>(ctx, input);
    JSValueFree<TypedArray>(ctx, output);
    JSValueFree<string>(ctx, propertyName);

    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_AnimationClip_proto_funcs[] = {
    JS_CGETSET_DEF("frameRate", js_fe_AnimationClip_frameRate_getter,
                   js_fe_AnimationClip_frameRate_setter),
    JS_CGETSET_DEF("length", js_fe_AnimationClip_length_getter, NULL),
    JS_CFUNC_DEF("SetCurve", 4, js_fe_AnimationClip_SetCurve),
};

extern "C" {
JSClassID js_fe_Animation_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Animation>() {
    return js_fe_Animation_class_id;
}

static JSClassDef js_fe_Animation_class = {
    "Animation",
    .finalizer = NULL,
};

static JSValue js_fe_Animation_Play(JSContext *ctx, JSValueConst this_value,
                                    int argc, JSValueConst *argv) {
    Animation *self =
        (Animation *)JS_GetOpaque2(ctx, this_value, js_fe_Animation_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    World *world;
    if (JSValueTo<World *>(ctx, &world, argv[0])) return JS_EXCEPTION;

    AnimationPlay(world, self);

    JSValueFree<World *>(ctx, world);

    return JS_UNDEFINED;
}
static JSValue js_fe_Animation_AddClip(JSContext *ctx, JSValueConst this_value,
                                       int argc, JSValueConst *argv) {
    Animation *self =
        (Animation *)JS_GetOpaque2(ctx, this_value, js_fe_Animation_class_id);
    if (!self) return JS_EXCEPTION;

    if (argc != 1) return JS_EXCEPTION;

    // TODO: goto fail and clear values if exception
    AnimationClip *clip;
    if (JSValueTo<AnimationClip *>(ctx, &clip, argv[0])) return JS_EXCEPTION;

    AnimationAddClip(self, clip);

    JSValueFree<AnimationClip *>(ctx, clip);

    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Animation_proto_funcs[] = {
    JS_CFUNC_DEF("Play", 1, js_fe_Animation_Play),
    JS_CFUNC_DEF("AddClip", 1, js_fe_Animation_AddClip),
};

extern "C" {
JSClassID js_fe_Light_class_id = 0;
}

template <>
inline JSClassID JSGetClassID<Light>() {
    return js_fe_Light_class_id;
}

static JSClassDef js_fe_Light_class = {
    "Light",
    .finalizer = NULL,
};

// enum LightType type getter
static JSValue js_fe_Light_type_getter(JSContext *ctx, JSValueConst this_val) {
    JSValue ret;
    enum LightType value;
    Light *self = (Light *)JS_GetOpaque2(ctx, this_val, js_fe_Light_class_id);
    if (!self) return JS_EXCEPTION;
    value = self->type;
    ret = JSValueFrom<enum LightType>(ctx, value);
    return ret;
}
// enum LightType type setter
static JSValue js_fe_Light_type_setter(JSContext *ctx, JSValueConst this_val,
                                       JSValue val) {
    Light *self = (Light *)JS_GetOpaque2(ctx, this_val, js_fe_Light_class_id);
    if (!self) return JS_EXCEPTION;
    enum LightType value;
    if (JSValueTo<enum LightType>(ctx, &value, val)) return JS_EXCEPTION;
    self->type = value;
    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_fe_Light_proto_funcs[] = {
    JS_CGETSET_DEF("type", js_fe_Light_type_getter, js_fe_Light_type_setter),
};

extern "C" {
int js_init_module_fishengine_extra(JSContext *ctx, JSModuleDef *m);
int js_fe_init_extra(JSContext *ctx, JSModuleDef *m);
JSClassID js_def_class(JSContext *ctx, JSClassDef *class_def,
                       const JSCFunctionListEntry proto_funcs[],
                       int proto_func_count);
}

#define CreateClass(name)                                                    \
    js_fe_##name##_class_id =                                                \
        js_def_class(ctx, &js_fe_##name##_class, js_fe_##name##_proto_funcs, \
                     countof(js_fe_##name##_proto_funcs))

int js_fe_init_extra(JSContext *ctx, JSModuleDef *m) {
    CreateClass(Transform);
    CreateClass(Camera);
    {
        JSValue proto, _class;
        JSClassID class_id = 0;
        JS_NewClassID(&class_id);
        js_fe_Texture_class_id = class_id;
        JS_NewClass(JS_GetRuntime(ctx), class_id, &js_fe_Texture_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_fe_Texture_proto_funcs,
                                   countof(js_fe_Texture_proto_funcs));
        JS_SetClassProto(ctx, class_id, proto);
        const char *class_name = "Texture";
        _class = JS_NewCFunction2(ctx, js_fe_Texture_ctor, class_name, 0,
                                  JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, _class, proto);
        JS_SetPropertyStr(
            ctx, _class, "FromDDSFile",
            JS_NewCFunction(ctx, js_fe_Texture_FromDDSFile, "FromDDSFile", 1));
        JS_SetModuleExport(ctx, m, class_name, _class);
    }
    {
        JSValue proto, _class;
        JSClassID class_id = 0;
        JS_NewClassID(&class_id);
        js_fe_Shader_class_id = class_id;
        JS_NewClass(JS_GetRuntime(ctx), class_id, &js_fe_Shader_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_fe_Shader_proto_funcs,
                                   countof(js_fe_Shader_proto_funcs));
        JS_SetClassProto(ctx, class_id, proto);
        const char *class_name = "Shader";
        _class = JS_NewCFunction2(ctx, js_fe_Shader_ctor, class_name, 0,
                                  JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, _class, proto);
        JS_SetPropertyStr(
            ctx, _class, "FromFile",
            JS_NewCFunction(ctx, js_fe_Shader_FromFile, "FromFile", 1));
        JS_SetPropertyStr(
            ctx, _class, "PropertyToID",
            JS_NewCFunction(ctx, js_fe_Shader_PropertyToID, "PropertyToID", 1));
        JS_SetModuleExport(ctx, m, class_name, _class);
    }
    {
        JSValue proto, _class;
        JSClassID class_id = 0;
        JS_NewClassID(&class_id);
        js_fe_Skin_class_id = class_id;
        JS_NewClass(JS_GetRuntime(ctx), class_id, &js_fe_Skin_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_fe_Skin_proto_funcs,
                                   countof(js_fe_Skin_proto_funcs));
        JS_SetClassProto(ctx, class_id, proto);
        const char *class_name = "Skin";
        _class = JS_NewCFunction2(ctx, js_fe_Skin_ctor, class_name, 0,
                                  JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, _class, proto);
        JS_SetModuleExport(ctx, m, class_name, _class);
    }
    {
        JSValue proto, _class;
        JSClassID class_id = 0;
        JS_NewClassID(&class_id);
        js_fe_Mesh_class_id = class_id;
        JS_NewClass(JS_GetRuntime(ctx), class_id, &js_fe_Mesh_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_fe_Mesh_proto_funcs,
                                   countof(js_fe_Mesh_proto_funcs));
        JS_SetClassProto(ctx, class_id, proto);
        const char *class_name = "Mesh";
        _class = JS_NewCFunction2(ctx, js_fe_Mesh_ctor, class_name, 0,
                                  JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, _class, proto);
        JS_SetPropertyStr(
            ctx, _class, "CombineMeshes",
            JS_NewCFunction(ctx, js_fe_Mesh_CombineMeshes, "CombineMeshes", 1));
        JS_SetModuleExport(ctx, m, class_name, _class);
    }
    {
        JSValue proto, _class;
        JSClassID class_id = 0;
        JS_NewClassID(&class_id);
        js_fe_Material_class_id = class_id;
        JS_NewClass(JS_GetRuntime(ctx), class_id, &js_fe_Material_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_fe_Material_proto_funcs,
                                   countof(js_fe_Material_proto_funcs));
        JS_SetClassProto(ctx, class_id, proto);
        const char *class_name = "Material";
        _class = JS_NewCFunction2(ctx, js_fe_Material_ctor, class_name, 0,
                                  JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, _class, proto);
        JS_SetModuleExport(ctx, m, class_name, _class);
    }
    CreateClass(Renderable);
    {
        JSValue proto, _class;
        JSClassID class_id = 0;
        JS_NewClassID(&class_id);
        js_fe_AnimationClip_class_id = class_id;
        JS_NewClass(JS_GetRuntime(ctx), class_id, &js_fe_AnimationClip_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_fe_AnimationClip_proto_funcs,
                                   countof(js_fe_AnimationClip_proto_funcs));
        JS_SetClassProto(ctx, class_id, proto);
        const char *class_name = "AnimationClip";
        _class = JS_NewCFunction2(ctx, js_fe_AnimationClip_ctor, class_name, 0,
                                  JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, _class, proto);
        JS_SetModuleExport(ctx, m, class_name, _class);
    }
    CreateClass(Animation);
    CreateClass(Light);
    return 0;
}

int js_init_module_fishengine_extra(JSContext *ctx, JSModuleDef *m) {
    JS_AddModuleExport(ctx, m, "Transform");
    JS_AddModuleExport(ctx, m, "Camera");
    JS_AddModuleExport(ctx, m, "Texture");
    JS_AddModuleExport(ctx, m, "Shader");
    JS_AddModuleExport(ctx, m, "Skin");
    JS_AddModuleExport(ctx, m, "Mesh");
    JS_AddModuleExport(ctx, m, "Material");
    JS_AddModuleExport(ctx, m, "Renderable");
    JS_AddModuleExport(ctx, m, "AnimationClip");
    JS_AddModuleExport(ctx, m, "Animation");
    JS_AddModuleExport(ctx, m, "Light");
    return 0;
}
